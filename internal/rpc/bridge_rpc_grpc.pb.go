// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: bridge_rpc.proto

package rpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// BridgeRpcClient is the client API for BridgeRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BridgeRpcClient interface {
	// App related calls
	GetCursorPos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PointResponse, error)
	GuiReady(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Quit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Restart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetShowOnStartup(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ShowOnStartup(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetShowSplashScreen(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ShowSplashScreen(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetDockIconVisible(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DockIconVisible(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetIsFirstGuiStart(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsFirstGuiStart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetIsAutostartOn(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsAutostartOn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetIsBetaEnabled(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsBetaEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	GoOs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	TriggerReset(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	LogPath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	LicensePath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	ReleaseNotesLink(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	LandingPageLink(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	SetColorSchemeName(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ColorSchemeName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	SetCurrentEmailClient(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CurrentEmailClient(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	ReportBug(ctx context.Context, in *ReportBugRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// login
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Login2FA(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Login2Passwords(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	LoginAbort(ctx context.Context, in *LoginAbortRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// update
	CheckUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	InstallUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SetIsAutomaticUpdateOn(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsAutomaticUpdateOn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	// cache
	SetIsCacheOnDiskEnabled(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsCacheOnDiskEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetDiskCachePath(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DiskCachePath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	ChangeLocalCache(ctx context.Context, in *ChangeLocalCacheRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// mail
	SetIsDoHEnabled(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsDoHEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	SetUseSslForSmtp(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UseSslForSmtp(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	Hostname(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	SetImapPort(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ImapPort(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	SetSmtpPort(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SmtpPort(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error)
	ChangePorts(ctx context.Context, in *ChangePortsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	IsPortFree(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error)
	// keychain
	AvailableKeychains(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AvailableKeychainsResponse, error)
	SetCurrentKeychain(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CurrentKeychain(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error)
	// User & user list
	GetUserList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserListResponse, error)
	GetUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*User, error)
	SetUserSplitMode(ctx context.Context, in *UserSplitModeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	LogoutUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RemoveUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConfigureUserAppleMail(ctx context.Context, in *ConfigureAppleMailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Server -> Client event stream
	GetEvents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BridgeRpc_GetEventsClient, error)
}

type bridgeRpcClient struct {
	cc grpc.ClientConnInterface
}

func NewBridgeRpcClient(cc grpc.ClientConnInterface) BridgeRpcClient {
	return &bridgeRpcClient{cc}
}

func (c *bridgeRpcClient) GetCursorPos(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PointResponse, error) {
	out := new(PointResponse)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/GetCursorPos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) GuiReady(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/GuiReady", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Quit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Quit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Restart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Restart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetShowOnStartup(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetShowOnStartup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ShowOnStartup(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ShowOnStartup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetShowSplashScreen(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetShowSplashScreen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ShowSplashScreen(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ShowSplashScreen", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetDockIconVisible(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetDockIconVisible", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) DockIconVisible(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/DockIconVisible", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetIsFirstGuiStart(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetIsFirstGuiStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsFirstGuiStart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsFirstGuiStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetIsAutostartOn(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetIsAutostartOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsAutostartOn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsAutostartOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetIsBetaEnabled(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetIsBetaEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsBetaEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsBetaEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) GoOs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/GoOs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) TriggerReset(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/TriggerReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Version(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Version", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) LogPath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/LogPath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) LicensePath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/LicensePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ReleaseNotesLink(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ReleaseNotesLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) LandingPageLink(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/LandingPageLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetColorSchemeName(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetColorSchemeName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ColorSchemeName(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ColorSchemeName", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetCurrentEmailClient(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetCurrentEmailClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) CurrentEmailClient(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/CurrentEmailClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ReportBug(ctx context.Context, in *ReportBugRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ReportBug", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Login2FA(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Login2FA", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Login2Passwords(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Login2Passwords", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) LoginAbort(ctx context.Context, in *LoginAbortRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/LoginAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) CheckUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/CheckUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) InstallUpdate(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/InstallUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetIsAutomaticUpdateOn(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetIsAutomaticUpdateOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsAutomaticUpdateOn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsAutomaticUpdateOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetIsCacheOnDiskEnabled(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetIsCacheOnDiskEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsCacheOnDiskEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsCacheOnDiskEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetDiskCachePath(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetDiskCachePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) DiskCachePath(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/DiskCachePath", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ChangeLocalCache(ctx context.Context, in *ChangeLocalCacheRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ChangeLocalCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetIsDoHEnabled(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetIsDoHEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsDoHEnabled(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsDoHEnabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetUseSslForSmtp(ctx context.Context, in *wrapperspb.BoolValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetUseSslForSmtp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) UseSslForSmtp(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/UseSslForSmtp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) Hostname(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/Hostname", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetImapPort(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetImapPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ImapPort(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ImapPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetSmtpPort(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetSmtpPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SmtpPort(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.Int32Value, error) {
	out := new(wrapperspb.Int32Value)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SmtpPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ChangePorts(ctx context.Context, in *ChangePortsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ChangePorts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) IsPortFree(ctx context.Context, in *wrapperspb.Int32Value, opts ...grpc.CallOption) (*wrapperspb.BoolValue, error) {
	out := new(wrapperspb.BoolValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/IsPortFree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) AvailableKeychains(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AvailableKeychainsResponse, error) {
	out := new(AvailableKeychainsResponse)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/AvailableKeychains", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetCurrentKeychain(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetCurrentKeychain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) CurrentKeychain(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*wrapperspb.StringValue, error) {
	out := new(wrapperspb.StringValue)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/CurrentKeychain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) GetUserList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UserListResponse, error) {
	out := new(UserListResponse)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/GetUserList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) GetUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/GetUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) SetUserSplitMode(ctx context.Context, in *UserSplitModeRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/SetUserSplitMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) LogoutUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/LogoutUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) RemoveUser(ctx context.Context, in *wrapperspb.StringValue, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/RemoveUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) ConfigureUserAppleMail(ctx context.Context, in *ConfigureAppleMailRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/bridgerpc.BridgeRpc/ConfigureUserAppleMail", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bridgeRpcClient) GetEvents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (BridgeRpc_GetEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &BridgeRpc_ServiceDesc.Streams[0], "/bridgerpc.BridgeRpc/GetEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &bridgeRpcGetEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BridgeRpc_GetEventsClient interface {
	Recv() (*StreamEvent, error)
	grpc.ClientStream
}

type bridgeRpcGetEventsClient struct {
	grpc.ClientStream
}

func (x *bridgeRpcGetEventsClient) Recv() (*StreamEvent, error) {
	m := new(StreamEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// BridgeRpcServer is the server API for BridgeRpc service.
// All implementations must embed UnimplementedBridgeRpcServer
// for forward compatibility
type BridgeRpcServer interface {
	// App related calls
	GetCursorPos(context.Context, *emptypb.Empty) (*PointResponse, error)
	GuiReady(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Quit(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Restart(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	SetShowOnStartup(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	ShowOnStartup(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetShowSplashScreen(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	ShowSplashScreen(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetDockIconVisible(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	DockIconVisible(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetIsFirstGuiStart(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	IsFirstGuiStart(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetIsAutostartOn(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	IsAutostartOn(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetIsBetaEnabled(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	IsBetaEnabled(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	GoOs(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	TriggerReset(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	Version(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	LogPath(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	LicensePath(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	ReleaseNotesLink(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	LandingPageLink(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	SetColorSchemeName(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	ColorSchemeName(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	SetCurrentEmailClient(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	CurrentEmailClient(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	ReportBug(context.Context, *ReportBugRequest) (*emptypb.Empty, error)
	// login
	Login(context.Context, *LoginRequest) (*emptypb.Empty, error)
	Login2FA(context.Context, *LoginRequest) (*emptypb.Empty, error)
	Login2Passwords(context.Context, *LoginRequest) (*emptypb.Empty, error)
	LoginAbort(context.Context, *LoginAbortRequest) (*emptypb.Empty, error)
	// update
	CheckUpdate(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	InstallUpdate(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	SetIsAutomaticUpdateOn(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	IsAutomaticUpdateOn(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	// cache
	SetIsCacheOnDiskEnabled(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	IsCacheOnDiskEnabled(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetDiskCachePath(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	DiskCachePath(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	ChangeLocalCache(context.Context, *ChangeLocalCacheRequest) (*emptypb.Empty, error)
	// mail
	SetIsDoHEnabled(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	IsDoHEnabled(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	SetUseSslForSmtp(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error)
	UseSslForSmtp(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error)
	Hostname(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	SetImapPort(context.Context, *wrapperspb.Int32Value) (*emptypb.Empty, error)
	ImapPort(context.Context, *emptypb.Empty) (*wrapperspb.Int32Value, error)
	SetSmtpPort(context.Context, *wrapperspb.Int32Value) (*emptypb.Empty, error)
	SmtpPort(context.Context, *emptypb.Empty) (*wrapperspb.Int32Value, error)
	ChangePorts(context.Context, *ChangePortsRequest) (*emptypb.Empty, error)
	IsPortFree(context.Context, *wrapperspb.Int32Value) (*wrapperspb.BoolValue, error)
	// keychain
	AvailableKeychains(context.Context, *emptypb.Empty) (*AvailableKeychainsResponse, error)
	SetCurrentKeychain(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	CurrentKeychain(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error)
	// User & user list
	GetUserList(context.Context, *emptypb.Empty) (*UserListResponse, error)
	GetUser(context.Context, *emptypb.Empty) (*User, error)
	SetUserSplitMode(context.Context, *UserSplitModeRequest) (*emptypb.Empty, error)
	LogoutUser(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	RemoveUser(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error)
	ConfigureUserAppleMail(context.Context, *ConfigureAppleMailRequest) (*emptypb.Empty, error)
	// Server -> Client event stream
	GetEvents(*emptypb.Empty, BridgeRpc_GetEventsServer) error
	mustEmbedUnimplementedBridgeRpcServer()
}

// UnimplementedBridgeRpcServer must be embedded to have forward compatible implementations.
type UnimplementedBridgeRpcServer struct {
}

func (UnimplementedBridgeRpcServer) GetCursorPos(context.Context, *emptypb.Empty) (*PointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCursorPos not implemented")
}
func (UnimplementedBridgeRpcServer) GuiReady(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GuiReady not implemented")
}
func (UnimplementedBridgeRpcServer) Quit(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Quit not implemented")
}
func (UnimplementedBridgeRpcServer) Restart(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Restart not implemented")
}
func (UnimplementedBridgeRpcServer) SetShowOnStartup(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetShowOnStartup not implemented")
}
func (UnimplementedBridgeRpcServer) ShowOnStartup(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowOnStartup not implemented")
}
func (UnimplementedBridgeRpcServer) SetShowSplashScreen(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetShowSplashScreen not implemented")
}
func (UnimplementedBridgeRpcServer) ShowSplashScreen(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowSplashScreen not implemented")
}
func (UnimplementedBridgeRpcServer) SetDockIconVisible(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDockIconVisible not implemented")
}
func (UnimplementedBridgeRpcServer) DockIconVisible(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DockIconVisible not implemented")
}
func (UnimplementedBridgeRpcServer) SetIsFirstGuiStart(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsFirstGuiStart not implemented")
}
func (UnimplementedBridgeRpcServer) IsFirstGuiStart(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsFirstGuiStart not implemented")
}
func (UnimplementedBridgeRpcServer) SetIsAutostartOn(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsAutostartOn not implemented")
}
func (UnimplementedBridgeRpcServer) IsAutostartOn(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAutostartOn not implemented")
}
func (UnimplementedBridgeRpcServer) SetIsBetaEnabled(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsBetaEnabled not implemented")
}
func (UnimplementedBridgeRpcServer) IsBetaEnabled(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBetaEnabled not implemented")
}
func (UnimplementedBridgeRpcServer) GoOs(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GoOs not implemented")
}
func (UnimplementedBridgeRpcServer) TriggerReset(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TriggerReset not implemented")
}
func (UnimplementedBridgeRpcServer) Version(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedBridgeRpcServer) LogPath(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogPath not implemented")
}
func (UnimplementedBridgeRpcServer) LicensePath(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LicensePath not implemented")
}
func (UnimplementedBridgeRpcServer) ReleaseNotesLink(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseNotesLink not implemented")
}
func (UnimplementedBridgeRpcServer) LandingPageLink(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LandingPageLink not implemented")
}
func (UnimplementedBridgeRpcServer) SetColorSchemeName(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetColorSchemeName not implemented")
}
func (UnimplementedBridgeRpcServer) ColorSchemeName(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ColorSchemeName not implemented")
}
func (UnimplementedBridgeRpcServer) SetCurrentEmailClient(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentEmailClient not implemented")
}
func (UnimplementedBridgeRpcServer) CurrentEmailClient(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentEmailClient not implemented")
}
func (UnimplementedBridgeRpcServer) ReportBug(context.Context, *ReportBugRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportBug not implemented")
}
func (UnimplementedBridgeRpcServer) Login(context.Context, *LoginRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedBridgeRpcServer) Login2FA(context.Context, *LoginRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login2FA not implemented")
}
func (UnimplementedBridgeRpcServer) Login2Passwords(context.Context, *LoginRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login2Passwords not implemented")
}
func (UnimplementedBridgeRpcServer) LoginAbort(context.Context, *LoginAbortRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginAbort not implemented")
}
func (UnimplementedBridgeRpcServer) CheckUpdate(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckUpdate not implemented")
}
func (UnimplementedBridgeRpcServer) InstallUpdate(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallUpdate not implemented")
}
func (UnimplementedBridgeRpcServer) SetIsAutomaticUpdateOn(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsAutomaticUpdateOn not implemented")
}
func (UnimplementedBridgeRpcServer) IsAutomaticUpdateOn(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsAutomaticUpdateOn not implemented")
}
func (UnimplementedBridgeRpcServer) SetIsCacheOnDiskEnabled(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsCacheOnDiskEnabled not implemented")
}
func (UnimplementedBridgeRpcServer) IsCacheOnDiskEnabled(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsCacheOnDiskEnabled not implemented")
}
func (UnimplementedBridgeRpcServer) SetDiskCachePath(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDiskCachePath not implemented")
}
func (UnimplementedBridgeRpcServer) DiskCachePath(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DiskCachePath not implemented")
}
func (UnimplementedBridgeRpcServer) ChangeLocalCache(context.Context, *ChangeLocalCacheRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeLocalCache not implemented")
}
func (UnimplementedBridgeRpcServer) SetIsDoHEnabled(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIsDoHEnabled not implemented")
}
func (UnimplementedBridgeRpcServer) IsDoHEnabled(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsDoHEnabled not implemented")
}
func (UnimplementedBridgeRpcServer) SetUseSslForSmtp(context.Context, *wrapperspb.BoolValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUseSslForSmtp not implemented")
}
func (UnimplementedBridgeRpcServer) UseSslForSmtp(context.Context, *emptypb.Empty) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseSslForSmtp not implemented")
}
func (UnimplementedBridgeRpcServer) Hostname(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hostname not implemented")
}
func (UnimplementedBridgeRpcServer) SetImapPort(context.Context, *wrapperspb.Int32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetImapPort not implemented")
}
func (UnimplementedBridgeRpcServer) ImapPort(context.Context, *emptypb.Empty) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImapPort not implemented")
}
func (UnimplementedBridgeRpcServer) SetSmtpPort(context.Context, *wrapperspb.Int32Value) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSmtpPort not implemented")
}
func (UnimplementedBridgeRpcServer) SmtpPort(context.Context, *emptypb.Empty) (*wrapperspb.Int32Value, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SmtpPort not implemented")
}
func (UnimplementedBridgeRpcServer) ChangePorts(context.Context, *ChangePortsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePorts not implemented")
}
func (UnimplementedBridgeRpcServer) IsPortFree(context.Context, *wrapperspb.Int32Value) (*wrapperspb.BoolValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPortFree not implemented")
}
func (UnimplementedBridgeRpcServer) AvailableKeychains(context.Context, *emptypb.Empty) (*AvailableKeychainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AvailableKeychains not implemented")
}
func (UnimplementedBridgeRpcServer) SetCurrentKeychain(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCurrentKeychain not implemented")
}
func (UnimplementedBridgeRpcServer) CurrentKeychain(context.Context, *emptypb.Empty) (*wrapperspb.StringValue, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CurrentKeychain not implemented")
}
func (UnimplementedBridgeRpcServer) GetUserList(context.Context, *emptypb.Empty) (*UserListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserList not implemented")
}
func (UnimplementedBridgeRpcServer) GetUser(context.Context, *emptypb.Empty) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedBridgeRpcServer) SetUserSplitMode(context.Context, *UserSplitModeRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserSplitMode not implemented")
}
func (UnimplementedBridgeRpcServer) LogoutUser(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogoutUser not implemented")
}
func (UnimplementedBridgeRpcServer) RemoveUser(context.Context, *wrapperspb.StringValue) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveUser not implemented")
}
func (UnimplementedBridgeRpcServer) ConfigureUserAppleMail(context.Context, *ConfigureAppleMailRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfigureUserAppleMail not implemented")
}
func (UnimplementedBridgeRpcServer) GetEvents(*emptypb.Empty, BridgeRpc_GetEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetEvents not implemented")
}
func (UnimplementedBridgeRpcServer) mustEmbedUnimplementedBridgeRpcServer() {}

// UnsafeBridgeRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BridgeRpcServer will
// result in compilation errors.
type UnsafeBridgeRpcServer interface {
	mustEmbedUnimplementedBridgeRpcServer()
}

func RegisterBridgeRpcServer(s grpc.ServiceRegistrar, srv BridgeRpcServer) {
	s.RegisterService(&BridgeRpc_ServiceDesc, srv)
}

func _BridgeRpc_GetCursorPos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).GetCursorPos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/GetCursorPos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).GetCursorPos(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_GuiReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).GuiReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/GuiReady",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).GuiReady(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Quit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Quit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Quit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Quit(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Restart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Restart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Restart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Restart(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetShowOnStartup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetShowOnStartup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetShowOnStartup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetShowOnStartup(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ShowOnStartup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ShowOnStartup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ShowOnStartup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ShowOnStartup(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetShowSplashScreen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetShowSplashScreen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetShowSplashScreen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetShowSplashScreen(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ShowSplashScreen_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ShowSplashScreen(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ShowSplashScreen",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ShowSplashScreen(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetDockIconVisible_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetDockIconVisible(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetDockIconVisible",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetDockIconVisible(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_DockIconVisible_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).DockIconVisible(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/DockIconVisible",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).DockIconVisible(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetIsFirstGuiStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetIsFirstGuiStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetIsFirstGuiStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetIsFirstGuiStart(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsFirstGuiStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsFirstGuiStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsFirstGuiStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsFirstGuiStart(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetIsAutostartOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetIsAutostartOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetIsAutostartOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetIsAutostartOn(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsAutostartOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsAutostartOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsAutostartOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsAutostartOn(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetIsBetaEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetIsBetaEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetIsBetaEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetIsBetaEnabled(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsBetaEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsBetaEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsBetaEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsBetaEnabled(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_GoOs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).GoOs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/GoOs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).GoOs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_TriggerReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).TriggerReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/TriggerReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).TriggerReset(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Version_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Version(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Version",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Version(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_LogPath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).LogPath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/LogPath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).LogPath(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_LicensePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).LicensePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/LicensePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).LicensePath(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ReleaseNotesLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ReleaseNotesLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ReleaseNotesLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ReleaseNotesLink(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_LandingPageLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).LandingPageLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/LandingPageLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).LandingPageLink(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetColorSchemeName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetColorSchemeName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetColorSchemeName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetColorSchemeName(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ColorSchemeName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ColorSchemeName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ColorSchemeName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ColorSchemeName(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetCurrentEmailClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetCurrentEmailClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetCurrentEmailClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetCurrentEmailClient(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_CurrentEmailClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).CurrentEmailClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/CurrentEmailClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).CurrentEmailClient(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ReportBug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportBugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ReportBug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ReportBug",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ReportBug(ctx, req.(*ReportBugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Login2FA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Login2FA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Login2FA",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Login2FA(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Login2Passwords_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Login2Passwords(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Login2Passwords",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Login2Passwords(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_LoginAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginAbortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).LoginAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/LoginAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).LoginAbort(ctx, req.(*LoginAbortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_CheckUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).CheckUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/CheckUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).CheckUpdate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_InstallUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).InstallUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/InstallUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).InstallUpdate(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetIsAutomaticUpdateOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetIsAutomaticUpdateOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetIsAutomaticUpdateOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetIsAutomaticUpdateOn(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsAutomaticUpdateOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsAutomaticUpdateOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsAutomaticUpdateOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsAutomaticUpdateOn(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetIsCacheOnDiskEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetIsCacheOnDiskEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetIsCacheOnDiskEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetIsCacheOnDiskEnabled(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsCacheOnDiskEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsCacheOnDiskEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsCacheOnDiskEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsCacheOnDiskEnabled(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetDiskCachePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetDiskCachePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetDiskCachePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetDiskCachePath(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_DiskCachePath_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).DiskCachePath(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/DiskCachePath",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).DiskCachePath(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ChangeLocalCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeLocalCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ChangeLocalCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ChangeLocalCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ChangeLocalCache(ctx, req.(*ChangeLocalCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetIsDoHEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetIsDoHEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetIsDoHEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetIsDoHEnabled(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsDoHEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsDoHEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsDoHEnabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsDoHEnabled(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetUseSslForSmtp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.BoolValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetUseSslForSmtp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetUseSslForSmtp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetUseSslForSmtp(ctx, req.(*wrapperspb.BoolValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_UseSslForSmtp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).UseSslForSmtp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/UseSslForSmtp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).UseSslForSmtp(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_Hostname_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).Hostname(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/Hostname",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).Hostname(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetImapPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetImapPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetImapPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetImapPort(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ImapPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ImapPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ImapPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ImapPort(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetSmtpPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetSmtpPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetSmtpPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetSmtpPort(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SmtpPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SmtpPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SmtpPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SmtpPort(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ChangePorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePortsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ChangePorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ChangePorts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ChangePorts(ctx, req.(*ChangePortsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_IsPortFree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.Int32Value)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).IsPortFree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/IsPortFree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).IsPortFree(ctx, req.(*wrapperspb.Int32Value))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_AvailableKeychains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).AvailableKeychains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/AvailableKeychains",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).AvailableKeychains(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetCurrentKeychain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetCurrentKeychain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetCurrentKeychain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetCurrentKeychain(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_CurrentKeychain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).CurrentKeychain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/CurrentKeychain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).CurrentKeychain(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_GetUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).GetUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/GetUserList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).GetUserList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).GetUser(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_SetUserSplitMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSplitModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).SetUserSplitMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/SetUserSplitMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).SetUserSplitMode(ctx, req.(*UserSplitModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_LogoutUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).LogoutUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/LogoutUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).LogoutUser(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_RemoveUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(wrapperspb.StringValue)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).RemoveUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/RemoveUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).RemoveUser(ctx, req.(*wrapperspb.StringValue))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_ConfigureUserAppleMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureAppleMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BridgeRpcServer).ConfigureUserAppleMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/bridgerpc.BridgeRpc/ConfigureUserAppleMail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BridgeRpcServer).ConfigureUserAppleMail(ctx, req.(*ConfigureAppleMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BridgeRpc_GetEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BridgeRpcServer).GetEvents(m, &bridgeRpcGetEventsServer{stream})
}

type BridgeRpc_GetEventsServer interface {
	Send(*StreamEvent) error
	grpc.ServerStream
}

type bridgeRpcGetEventsServer struct {
	grpc.ServerStream
}

func (x *bridgeRpcGetEventsServer) Send(m *StreamEvent) error {
	return x.ServerStream.SendMsg(m)
}

// BridgeRpc_ServiceDesc is the grpc.ServiceDesc for BridgeRpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BridgeRpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "bridgerpc.BridgeRpc",
	HandlerType: (*BridgeRpcServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCursorPos",
			Handler:    _BridgeRpc_GetCursorPos_Handler,
		},
		{
			MethodName: "GuiReady",
			Handler:    _BridgeRpc_GuiReady_Handler,
		},
		{
			MethodName: "Quit",
			Handler:    _BridgeRpc_Quit_Handler,
		},
		{
			MethodName: "Restart",
			Handler:    _BridgeRpc_Restart_Handler,
		},
		{
			MethodName: "SetShowOnStartup",
			Handler:    _BridgeRpc_SetShowOnStartup_Handler,
		},
		{
			MethodName: "ShowOnStartup",
			Handler:    _BridgeRpc_ShowOnStartup_Handler,
		},
		{
			MethodName: "SetShowSplashScreen",
			Handler:    _BridgeRpc_SetShowSplashScreen_Handler,
		},
		{
			MethodName: "ShowSplashScreen",
			Handler:    _BridgeRpc_ShowSplashScreen_Handler,
		},
		{
			MethodName: "SetDockIconVisible",
			Handler:    _BridgeRpc_SetDockIconVisible_Handler,
		},
		{
			MethodName: "DockIconVisible",
			Handler:    _BridgeRpc_DockIconVisible_Handler,
		},
		{
			MethodName: "SetIsFirstGuiStart",
			Handler:    _BridgeRpc_SetIsFirstGuiStart_Handler,
		},
		{
			MethodName: "IsFirstGuiStart",
			Handler:    _BridgeRpc_IsFirstGuiStart_Handler,
		},
		{
			MethodName: "SetIsAutostartOn",
			Handler:    _BridgeRpc_SetIsAutostartOn_Handler,
		},
		{
			MethodName: "IsAutostartOn",
			Handler:    _BridgeRpc_IsAutostartOn_Handler,
		},
		{
			MethodName: "SetIsBetaEnabled",
			Handler:    _BridgeRpc_SetIsBetaEnabled_Handler,
		},
		{
			MethodName: "IsBetaEnabled",
			Handler:    _BridgeRpc_IsBetaEnabled_Handler,
		},
		{
			MethodName: "GoOs",
			Handler:    _BridgeRpc_GoOs_Handler,
		},
		{
			MethodName: "TriggerReset",
			Handler:    _BridgeRpc_TriggerReset_Handler,
		},
		{
			MethodName: "Version",
			Handler:    _BridgeRpc_Version_Handler,
		},
		{
			MethodName: "LogPath",
			Handler:    _BridgeRpc_LogPath_Handler,
		},
		{
			MethodName: "LicensePath",
			Handler:    _BridgeRpc_LicensePath_Handler,
		},
		{
			MethodName: "ReleaseNotesLink",
			Handler:    _BridgeRpc_ReleaseNotesLink_Handler,
		},
		{
			MethodName: "LandingPageLink",
			Handler:    _BridgeRpc_LandingPageLink_Handler,
		},
		{
			MethodName: "SetColorSchemeName",
			Handler:    _BridgeRpc_SetColorSchemeName_Handler,
		},
		{
			MethodName: "ColorSchemeName",
			Handler:    _BridgeRpc_ColorSchemeName_Handler,
		},
		{
			MethodName: "SetCurrentEmailClient",
			Handler:    _BridgeRpc_SetCurrentEmailClient_Handler,
		},
		{
			MethodName: "CurrentEmailClient",
			Handler:    _BridgeRpc_CurrentEmailClient_Handler,
		},
		{
			MethodName: "ReportBug",
			Handler:    _BridgeRpc_ReportBug_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _BridgeRpc_Login_Handler,
		},
		{
			MethodName: "Login2FA",
			Handler:    _BridgeRpc_Login2FA_Handler,
		},
		{
			MethodName: "Login2Passwords",
			Handler:    _BridgeRpc_Login2Passwords_Handler,
		},
		{
			MethodName: "LoginAbort",
			Handler:    _BridgeRpc_LoginAbort_Handler,
		},
		{
			MethodName: "CheckUpdate",
			Handler:    _BridgeRpc_CheckUpdate_Handler,
		},
		{
			MethodName: "InstallUpdate",
			Handler:    _BridgeRpc_InstallUpdate_Handler,
		},
		{
			MethodName: "SetIsAutomaticUpdateOn",
			Handler:    _BridgeRpc_SetIsAutomaticUpdateOn_Handler,
		},
		{
			MethodName: "IsAutomaticUpdateOn",
			Handler:    _BridgeRpc_IsAutomaticUpdateOn_Handler,
		},
		{
			MethodName: "SetIsCacheOnDiskEnabled",
			Handler:    _BridgeRpc_SetIsCacheOnDiskEnabled_Handler,
		},
		{
			MethodName: "IsCacheOnDiskEnabled",
			Handler:    _BridgeRpc_IsCacheOnDiskEnabled_Handler,
		},
		{
			MethodName: "SetDiskCachePath",
			Handler:    _BridgeRpc_SetDiskCachePath_Handler,
		},
		{
			MethodName: "DiskCachePath",
			Handler:    _BridgeRpc_DiskCachePath_Handler,
		},
		{
			MethodName: "ChangeLocalCache",
			Handler:    _BridgeRpc_ChangeLocalCache_Handler,
		},
		{
			MethodName: "SetIsDoHEnabled",
			Handler:    _BridgeRpc_SetIsDoHEnabled_Handler,
		},
		{
			MethodName: "IsDoHEnabled",
			Handler:    _BridgeRpc_IsDoHEnabled_Handler,
		},
		{
			MethodName: "SetUseSslForSmtp",
			Handler:    _BridgeRpc_SetUseSslForSmtp_Handler,
		},
		{
			MethodName: "UseSslForSmtp",
			Handler:    _BridgeRpc_UseSslForSmtp_Handler,
		},
		{
			MethodName: "Hostname",
			Handler:    _BridgeRpc_Hostname_Handler,
		},
		{
			MethodName: "SetImapPort",
			Handler:    _BridgeRpc_SetImapPort_Handler,
		},
		{
			MethodName: "ImapPort",
			Handler:    _BridgeRpc_ImapPort_Handler,
		},
		{
			MethodName: "SetSmtpPort",
			Handler:    _BridgeRpc_SetSmtpPort_Handler,
		},
		{
			MethodName: "SmtpPort",
			Handler:    _BridgeRpc_SmtpPort_Handler,
		},
		{
			MethodName: "ChangePorts",
			Handler:    _BridgeRpc_ChangePorts_Handler,
		},
		{
			MethodName: "IsPortFree",
			Handler:    _BridgeRpc_IsPortFree_Handler,
		},
		{
			MethodName: "AvailableKeychains",
			Handler:    _BridgeRpc_AvailableKeychains_Handler,
		},
		{
			MethodName: "SetCurrentKeychain",
			Handler:    _BridgeRpc_SetCurrentKeychain_Handler,
		},
		{
			MethodName: "CurrentKeychain",
			Handler:    _BridgeRpc_CurrentKeychain_Handler,
		},
		{
			MethodName: "GetUserList",
			Handler:    _BridgeRpc_GetUserList_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _BridgeRpc_GetUser_Handler,
		},
		{
			MethodName: "SetUserSplitMode",
			Handler:    _BridgeRpc_SetUserSplitMode_Handler,
		},
		{
			MethodName: "LogoutUser",
			Handler:    _BridgeRpc_LogoutUser_Handler,
		},
		{
			MethodName: "RemoveUser",
			Handler:    _BridgeRpc_RemoveUser_Handler,
		},
		{
			MethodName: "ConfigureUserAppleMail",
			Handler:    _BridgeRpc_ConfigureUserAppleMail_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetEvents",
			Handler:       _BridgeRpc_GetEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "bridge_rpc.proto",
}
